Rotation Algorithms
                             
Figure 1
To implement the rotation algorithms we have decided to use a strategy pattern, as shown in Figure 1 above, to allow the MainThread to update a RotationAlgorithm without specifically knowing which it is. The main thread includes a List of RotationAlgorithms that get initialized, based on GUI parameters, to a more specific algorithm such as ARA, RSRMA, or RSRMA’ . It was easy to see that a strategy pattern was needed, simply because all the algorithms shared a number of things in common. Using the strategy pattern allowed us to abstract common methods and variables, such as the delay (d), sectors (k) variables and mech0 and mech1 methods. This produced more elegant code. Each algorithm takes in a Sensor that it will be responsible for rotating, and based on the Sensor that’s given it determines the algorithm’s delay (d) and number of sectors (k).  Because this algorithms do not spawn their own threads and rely on the MainThread to loop through them, the delay loops were done slightly differently. The update methods for each algorithm are responsible for rotating the Sensor. In the update methods the outer_loop and inner_loop variables are used to simulate delay. In the case of the ARAlgorithm, where the original algorithm is described in the assignment and the additional papers, the for loop inside of the while loop acted as a delay. The way that was implemented was that the while loop was the MainThread update loop and the inner for-loop was represented by the outer_loop variable, to cause delay. To be more specific the outer_loop variable upon initialization of an ARAlgorithm is set to the Sensor’s ‘d’, it’s color/prime. Evertime the update happens for the ARAlgorithm the outer_loop variable decrements, until it reaches  zero. When it is zero the Sensor updates, causing a turn, and the outer_loop variable is reinitiated to the Sensor’s ‘d’. This simulates the delay in the algorithm, and although the loop does not look the same, it functions the same way. For the RSRMA and RSRMA’ the loops where handled in a similar fashion. However each time the outer_loop variable reached zero, it would randomly pick between mech0 and mech1. With the level of abstraction that was made by implementing the strategy pattern, the RSRMAGeneral contained majority of how the randomized algorithms functioned. It was noticed that the difference between RSRMA and RSRMA’ was that one passed in ‘k’ and ‘d’ to the mech’s, while the other passed in two ‘k’, treating one of the ‘k’ as a ‘d’. Thus the only code that RSRMAlgorithm and RSRMAlgorithmPrime possess is one assigns the Sensor’s ‘k’ to the algorithm’s ‘k’ and the Sensor’s ‘d’ to the algorithm’s ‘d’ while the other assigns the Sensor’s ‘k’ to both the algorithm’s ‘k’ and ‘d’.

