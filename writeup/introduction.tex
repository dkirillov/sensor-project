\section{Introduction}
In this document we examine the results of programmatically simulating algorithms for symmetry breaking for rotating directional sensors. We use the (D,D) model, whereby the sensors have identical transmission and reception beam width. Three algorithms are implemented.

\subsection{Antennae Rotation Algorithm}
Technically this is the ARAR algorithm denoted in the Neighbor Discovery in a Sensor Network with Directional Antennae in the paper.
In this algorithm each sensor rotates one sector, then delays for $d_{u}$ steps while transmitting and listening for neighbours. In order to properly ensure that the sensors don't a)rotate with the same delay and b)rotate with delays that are multiples of one another, $d_{u}$ is a prime number based on a colouring of the graph, where  $d_{u}$ > k. This is the only purely deterministic algorithm, so it is guaranteed to finish (ie we have a determinable finish time in addition to expected time). Although it performs tolerably well with wide sensor beams (ie low k values), it is in general not the best performing algorithm. And a particularly dense graph could conceivably run into problems. Most notably that colouring algorithms are NP-hard (though I am sure there are tolerable algorithms for it), but also since the value of the prime numbers needed raises with the density of the graph, two adjacent sensors with high value primes can take a long time to detect one another. 

\subsection{Random Selection Rotation Mechanism Algorithm}
In the RSRMA algorithm chooses between two algorithms, Mech0 and Mech1. Both take two arguments. Mech0 rotates with no sector delay, while Mech1 rotates using a sector delay. RSRMA calls these algorithms with the number of sectors as both arguments. So Mech0 rotates through its k sectors k times with no delay, while Mech1 rotates one sector then delays for k time while sending and listening for signals. At the end of each iteration it chooses Mech0 or Mech1 at random.

Perhaps surprisingly, this is the best performing algorithm of the three detailed here. 

\subsection{Random Selection Rotation Mechanism Algorithm Prime}
RSRMA' operates much the same as RSRMA, except that instead of using k for the second argument it passes in a prime number d. So it will rotate through the sectors d times in Mech0, or rotate with delay d in each sector in Mech1. At the end of each iteration it again chooses Mech0 or Mech1 at random.

The prime numbers are again based on the colouring of the graph, ensuring there is no symmetry in the rotation of the sensors, while the random element improves the run time over ARA. However, it still does not perform as well as RSRMA.

